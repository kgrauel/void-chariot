renderer {
    uniform vec2 iResolution; // viewport resolution (in pixels)
    uniform float iTime;      // shader playback time (in seconds)
    uniform vec3 camPos;
    uniform vec3 lookAt;
    uniform float focalLength;
    uniform float farPlaneDistance;
    uniform float maxIterations;
    uniform int iFrame;
    uniform vec3 directionTowardSun;
    uniform vec3 sunColor;
    uniform float aoIterations;
    uniform float aoDistance;
    uniform float aoPower;

    const vec3 aoDirections[12] = vec3[12] (
        vec3(0.357407, 0.357407, 0.862856),
        vec3(0.357407, 0.862856, 0.357407),
        vec3(0.862856, 0.357407, 0.357407),
        vec3(-0.357407, 0.357407, 0.862856),
        vec3(-0.357407, 0.862856, 0.357407),
        vec3(-0.862856, 0.357407, 0.357407),
        vec3(0.357407, -0.357407, 0.862856),
        vec3(0.357407, -0.862856, 0.357407),
        vec3(0.862856, -0.357407, 0.357407),
        vec3(-0.357407, -0.357407, 0.862856),
        vec3(-0.357407, -0.862856, 0.357407),
        vec3(-0.862856, -0.357407, 0.357407)
    );

    vec3 approximateNormal(vec3 pos) {
        vec2 e = vec2(0.5773, -0.5773);
        return normalize(
            e.xyy * sdf(pos + e.xyy * 0.005) +
            e.yyx * sdf(pos + e.yyx * 0.005) + 
            e.yxy * sdf(pos + e.yxy * 0.005) + 
            e.xxx * sdf(pos + e.xxx * 0.005)
        );
    }

    float ao(vec3 start, vec3 normal) {
        float dist = aoDistance;
        float occ = 1.0;
        for (float i = -0.001; i < aoIterations; i++) {
            occ = min(occ, sdf(start + dist * normal) / dist);
            dist *= aoPower;
        }
        occ = max(occ, 0.0);
        return occ;
    }


    void main() {
        // Near plane frustum coords with center at (0, 0) and vertical
        // extent [-1, 1]. Horizontal varies by aspect ratio.
        vec2 frustum = vUv * 2.0 - vec2(1.0);
        frustum.x *= iResolution.x / iResolution.y;

        // Calculate basis vectors for camera.
        vec3 forward = normalize(lookAt - camPos);
        vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
        vec3 up = cross(right, forward);

        // Calculate view ray (unit vector from camera through correct
        // pixel of frustum).
        vec3 ray = normalize(
            frustum.x * right + frustum.y * up + focalLength * forward
        );

        // Set up raymarching loop.
        float t = 0.0;
        float steps = -0.001; // this bias prevents rounding error
        vec3 p = camPos;
        float distance = 50.0;

        // Raymarch.
        while (t <= farPlaneDistance && steps <= maxIterations) {
            distance = sdf(p);
            if (distance < 0.001) {
                break;
            }

            p += distance * ray;
            steps += 1.0;
        }

        // Lighting.
        vec3 color = vec3(0.0, 0.0, 0.0);
        vec3 pigment = getPigment(p);
        if (distance < 0.002 && distance > -0.1) {
            vec3 normal = approximateNormal(p);
            //float diffuse = clamp(dot(normal, directionTowardSun), 0.0, 1.0);
            vec3 pigment = getPigment(p);
            //color = diffuse * sunColor * pigment;
            vec3 f = normal;
            vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));
            vec3 u = cross(s, f);
            mat3 m = mat3(u, s, f);
            for (float i = 0; i < 12; i++) {
                vec3 aoRay = m * aoDirections[i];
                color += ao(p + normal * 0.005, aoRay) / 12.0 * pigment * (0.5 + 0.5 * dot(aoRay, directionTowardSun));
            }
        } else {
            color = sky(ray);
        }
        


        color = pow(color, vec3(0.45));
        gl_FragColor = vec4(color, 1.0);
    }
}